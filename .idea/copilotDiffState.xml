<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/bureaucratic-system/src/main/java/org/example/config/ConfigLoader.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bureaucratic-system/src/main/java/org/example/config/ConfigLoader.java" />
              <option name="originalContent" value="package org.example.config;&#10;&#10;import org.example.model.Config;&#10;import org.yaml.snakeyaml.Yaml;&#10;import org.yaml.snakeyaml.constructor.Constructor;&#10;&#10;import java.io.InputStream;&#10;&#10;public class ConfigLoader {&#10;&#10;    public static Config loadConfig(String resourcePath) {&#10;        Yaml yaml = new Yaml(new Constructor(Config.class));&#10;        InputStream inputStream = ConfigLoader.class.getClassLoader().getResourceAsStream(resourcePath);&#10;&#10;        if (inputStream == null) {&#10;            throw new RuntimeException(&quot;Configuration file not found: &quot; + resourcePath);&#10;        }&#10;&#10;        return yaml.load(inputStream);&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package org.example.config;&#10;&#10;import org.example.model.Config;&#10;import org.yaml.snakeyaml.Yaml;&#10;import org.yaml.snakeyaml.constructor.Constructor;&#10;import org.yaml.snakeyaml.LoaderOptions;&#10;&#10;import java.io.InputStream;&#10;&#10;public class ConfigLoader {&#10;    &#10;    public static Config loadConfig(String resourcePath) {&#10;        LoaderOptions loaderOptions = new LoaderOptions();&#10;        Yaml yaml = new Yaml(new Constructor(Config.class, loaderOptions));&#10;        InputStream inputStream = ConfigLoader.class.getClassLoader().getResourceAsStream(resourcePath);&#10;        &#10;        if (inputStream == null) {&#10;            throw new RuntimeException(&quot;Configuration file not found: &quot; + resourcePath);&#10;        }&#10;        &#10;        return yaml.load(inputStream);&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bureaucratic-system/src/main/java/org/example/graph/DependencyGraph.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bureaucratic-system/src/main/java/org/example/graph/DependencyGraph.java" />
              <option name="originalContent" value="package org.example.graph;&#10;&#10;import org.example.model.DocumentType;&#10;&#10;import java.util.*;&#10;&#10;public class DependencyGraph {&#10;    private final Map&lt;String, DocumentType&gt; documents;&#10;    private final Map&lt;String, List&lt;String&gt;&gt; adjacencyList;&#10;&#10;    public DependencyGraph() {&#10;        this.documents = new HashMap&lt;&gt;();&#10;        this.adjacencyList = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    public void addDocument(DocumentType document) {&#10;        documents.put(document.getName(), document);&#10;        adjacencyList.putIfAbsent(document.getName(), new ArrayList&lt;&gt;());&#10;&#10;        for (String requiredDoc : document.getRequiredDocuments()) {&#10;            adjacencyList.putIfAbsent(requiredDoc, new ArrayList&lt;&gt;());&#10;            adjacencyList.get(requiredDoc).add(document.getName());&#10;        }&#10;    }&#10;&#10;    public DocumentType getDocument(String name) {&#10;        return documents.get(name);&#10;    }&#10;&#10;    /**&#10;     * Returns the order in which documents must be obtained to get the target document.&#10;     * Uses topological sort to determine the correct order.&#10;     */&#10;    public List&lt;String&gt; getDocumentPath(String targetDocument) {&#10;        if (!documents.containsKey(targetDocument)) {&#10;            return Collections.emptyList();&#10;        }&#10;&#10;        List&lt;String&gt; path = new ArrayList&lt;&gt;();&#10;        Set&lt;String&gt; visited = new HashSet&lt;&gt;();&#10;        Set&lt;String&gt; recursionStack = new HashSet&lt;&gt;();&#10;&#10;        if (hasCycle(targetDocument, visited, recursionStack)) {&#10;            System.out.println(&quot;⚠️  Warning: Circular dependency detected for &quot; + targetDocument);&#10;            return Collections.emptyList();&#10;        }&#10;&#10;        visited.clear();&#10;        buildPath(targetDocument, visited, path);&#10;&#10;        return path;&#10;    }&#10;&#10;    private void buildPath(String documentName, Set&lt;String&gt; visited, List&lt;String&gt; path) {&#10;        if (visited.contains(documentName)) {&#10;            return;&#10;        }&#10;&#10;        visited.add(documentName);&#10;        DocumentType doc = documents.get(documentName);&#10;&#10;        if (doc != null) {&#10;            // First, get all required documents&#10;            for (String requiredDoc : doc.getRequiredDocuments()) {&#10;                buildPath(requiredDoc, visited, path);&#10;            }&#10;        }&#10;&#10;        // Then add this document&#10;        path.add(documentName);&#10;    }&#10;&#10;    private boolean hasCycle(String documentName, Set&lt;String&gt; visited, Set&lt;String&gt; recursionStack) {&#10;        visited.add(documentName);&#10;        recursionStack.add(documentName);&#10;&#10;        DocumentType doc = documents.get(documentName);&#10;        if (doc != null) {&#10;            for (String requiredDoc : doc.getRequiredDocuments()) {&#10;                if (!visited.contains(requiredDoc)) {&#10;                    if (hasCycle(requiredDoc, visited, recursionStack)) {&#10;                        return true;&#10;                    }&#10;                } else if (recursionStack.contains(requiredDoc)) {&#10;                    return true;&#10;                }&#10;            }&#10;        }&#10;&#10;        recursionStack.remove(documentName);&#10;        return false;&#10;    }&#10;&#10;    public void printDependencies() {&#10;        System.out.println(&quot;\n Document Dependencies:&quot;);&#10;        for (DocumentType doc : documents.values()) {&#10;            if (doc.getRequiredDocuments().isEmpty()) {&#10;                System.out.println(&quot;  &quot; + doc.getName() + &quot; (base document)&quot;);&#10;            } else {&#10;                System.out.println(&quot;  &quot; + doc.getName() + &quot; requires: &quot; + doc.getRequiredDocuments());&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package org.example.graph;&#10;&#10;import org.example.model.DocumentType;&#10;&#10;import java.util.*;&#10;&#10;public class DependencyGraph {&#10;    private final Map&lt;String, DocumentType&gt; documents;&#10;    private final Map&lt;String, List&lt;String&gt;&gt; adjacencyList;&#10;&#10;    public DependencyGraph() {&#10;        this.documents = new HashMap&lt;&gt;();&#10;        this.adjacencyList = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    public void addDocument(DocumentType document) {&#10;        documents.put(document.getName(), document);&#10;        adjacencyList.putIfAbsent(document.getName(), new ArrayList&lt;&gt;());&#10;&#10;        for (String requiredDoc : document.getRequiredDocuments()) {&#10;            adjacencyList.putIfAbsent(requiredDoc, new ArrayList&lt;&gt;());&#10;            adjacencyList.get(requiredDoc).add(document.getName());&#10;        }&#10;    }&#10;&#10;    public DocumentType getDocument(String name) {&#10;        return documents.get(name);&#10;    }&#10;&#10;    /**&#10;     * Returns the order in which documents must be obtained to get the target document.&#10;     * Uses topological sort to determine the correct order.&#10;     */&#10;    public List&lt;String&gt; getDocumentPath(String targetDocument) {&#10;        if (!documents.containsKey(targetDocument)) {&#10;            return Collections.emptyList();&#10;        }&#10;&#10;        List&lt;String&gt; path = new ArrayList&lt;&gt;();&#10;        Set&lt;String&gt; visited = new HashSet&lt;&gt;();&#10;        Set&lt;String&gt; recursionStack = new HashSet&lt;&gt;();&#10;&#10;        if (hasCycle(targetDocument, visited, recursionStack)) {&#10;            System.out.println(&quot;⚠️  Warning: Circular dependency detected for &quot; + targetDocument);&#10;            return Collections.emptyList();&#10;        }&#10;&#10;        visited.clear();&#10;        buildPath(targetDocument, visited, path);&#10;&#10;        return path;&#10;    }&#10;&#10;    private void buildPath(String documentName, Set&lt;String&gt; visited, List&lt;String&gt; path) {&#10;        if (visited.contains(documentName)) {&#10;            return;&#10;        }&#10;&#10;        visited.add(documentName);&#10;        DocumentType doc = documents.get(documentName);&#10;&#10;        if (doc != null) {&#10;            // First, get all required documents&#10;            for (String requiredDoc : doc.getRequiredDocuments()) {&#10;                buildPath(requiredDoc, visited, path);&#10;            }&#10;        }&#10;&#10;        // Then add this document&#10;        path.add(documentName);&#10;    }&#10;&#10;    private boolean hasCycle(String documentName, Set&lt;String&gt; visited, Set&lt;String&gt; recursionStack) {&#10;        visited.add(documentName);&#10;        recursionStack.add(documentName);&#10;&#10;        DocumentType doc = documents.get(documentName);&#10;        if (doc != null) {&#10;            for (String requiredDoc : doc.getRequiredDocuments()) {&#10;                if (!visited.contains(requiredDoc)) {&#10;                    if (hasCycle(requiredDoc, visited, recursionStack)) {&#10;                        return true;&#10;                    }&#10;                } else if (recursionStack.contains(requiredDoc)) {&#10;                    return true;&#10;                }&#10;            }&#10;        }&#10;&#10;        recursionStack.remove(documentName);&#10;        return false;&#10;    }&#10;&#10;    public void printDependencies() {&#10;        System.out.println(&quot;\n*** Document Dependencies ***&quot;);&#10;        for (DocumentType doc : documents.values()) {&#10;            if (doc.getRequiredDocuments().isEmpty()) {&#10;                System.out.println(&quot;  &quot; + doc.getName() + &quot; (base document)&quot;);&#10;            } else {&#10;                System.out.println(&quot;  &quot; + doc.getName() + &quot; requires: &quot; + doc.getRequiredDocuments());&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bureaucratic-system/src/main/java/org/example/model/Client.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bureaucratic-system/src/main/java/org/example/model/Client.java" />
              <option name="originalContent" value="package org.example.model;&#10;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;public class Client implements Runnable {&#10;    private static final AtomicInteger clientIdGenerator = new AtomicInteger(1);&#10;&#10;    private final int id;&#10;    private final String name;&#10;    private final String desiredDocument;&#10;    private final List&lt;String&gt; documentPath;&#10;    private final Set&lt;String&gt; obtainedDocuments;&#10;    private final Map&lt;String, Office&gt; officeMap;&#10;    private volatile String currentDocumentNeeded;&#10;    private int currentStep;&#10;&#10;    public Client(String desiredDocument, List&lt;String&gt; documentPath, Map&lt;String, Office&gt; officeMap) {&#10;        this.id = clientIdGenerator.getAndIncrement();&#10;        this.name = &quot;Client-&quot; + id;&#10;        this.desiredDocument = desiredDocument;&#10;        this.documentPath = documentPath;&#10;        this.obtainedDocuments = ConcurrentHashMap.newKeySet();&#10;        this.officeMap = officeMap;&#10;        this.currentStep = 0;&#10;    }&#10;&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    public String getCurrentDocumentNeeded() {&#10;        return currentDocumentNeeded;&#10;    }&#10;&#10;    public synchronized void receiveDocument(String documentName) {&#10;        obtainedDocuments.add(documentName);&#10;        notifyAll();&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        System.out.println(&quot; &quot; + name + &quot; wants to obtain: &quot; + desiredDocument);&#10;        System.out.println(&quot;   Path required: &quot; + documentPath);&#10;&#10;        try {&#10;            // Follow the document path&#10;            for (String docName : documentPath) {&#10;                currentDocumentNeeded = docName;&#10;&#10;                // Find which office issues this document&#10;                Office targetOffice = findOfficeForDocument(docName);&#10;                if (targetOffice == null) {&#10;                    System.out.println(&quot;❌ &quot; + name + &quot; ERROR: No office issues &quot; + docName);&#10;                    return;&#10;                }&#10;&#10;                System.out.println(&quot; &quot; + name + &quot; going to &quot; + targetOffice.getName() + &quot; for &quot; + docName);&#10;&#10;                // Join queue at the office&#10;                targetOffice.assignClient(this);&#10;&#10;                // Wait until document is received&#10;                synchronized (this) {&#10;                    while (!obtainedDocuments.contains(docName)) {&#10;                        wait();&#10;                    }&#10;                }&#10;&#10;                currentStep++;&#10;            }&#10;&#10;            System.out.println(&quot; &quot; + name + &quot; successfully obtained &quot; + desiredDocument + &quot;!&quot;);&#10;&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;            System.out.println(&quot;❌ &quot; + name + &quot; was interrupted.&quot;);&#10;        }&#10;    }&#10;&#10;    private Office findOfficeForDocument(String documentName) {&#10;        for (Office office : officeMap.values()) {&#10;            if (office.canIssue(documentName)) {&#10;                return office;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package org.example.model;&#10;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;public class Client implements Runnable {&#10;    private static final AtomicInteger clientIdGenerator = new AtomicInteger(1);&#10;&#10;    private final int id;&#10;    private final String name;&#10;    private final String desiredDocument;&#10;    private final List&lt;String&gt; documentPath;&#10;    private final Set&lt;String&gt; obtainedDocuments;&#10;    private final Map&lt;String, Office&gt; officeMap;&#10;    private volatile String currentDocumentNeeded;&#10;    private int currentStep;&#10;&#10;    public Client(String desiredDocument, List&lt;String&gt; documentPath, Map&lt;String, Office&gt; officeMap) {&#10;        this.id = clientIdGenerator.getAndIncrement();&#10;        this.name = &quot;Client-&quot; + id;&#10;        this.desiredDocument = desiredDocument;&#10;        this.documentPath = documentPath;&#10;        this.obtainedDocuments = ConcurrentHashMap.newKeySet();&#10;        this.officeMap = officeMap;&#10;        this.currentStep = 0;&#10;    }&#10;&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    public String getCurrentDocumentNeeded() {&#10;        return currentDocumentNeeded;&#10;    }&#10;&#10;    public synchronized void receiveDocument(String documentName) {&#10;        obtainedDocuments.add(documentName);&#10;        notifyAll();&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        System.out.println(&quot;[CLIENT] &quot; + name + &quot; wants to obtain: &quot; + desiredDocument);&#10;        System.out.println(&quot;         Path required: &quot; + documentPath);&#10;        &#10;        try {&#10;            // Follow the document path&#10;            for (String docName : documentPath) {&#10;                currentDocumentNeeded = docName;&#10;                &#10;                // Find which office issues this document&#10;                Office targetOffice = findOfficeForDocument(docName);&#10;                if (targetOffice == null) {&#10;                    System.out.println(&quot;[ERROR] &quot; + name + &quot; ERROR: No office issues &quot; + docName);&#10;                    return;&#10;                }&#10;                &#10;                System.out.println(&quot;[GOING] &quot; + name + &quot; going to &quot; + targetOffice.getName() + &quot; for &quot; + docName);&#10;                &#10;                // Join queue at the office&#10;                targetOffice.assignClient(this);&#10;                &#10;                // Wait until document is received&#10;                synchronized (this) {&#10;                    while (!obtainedDocuments.contains(docName)) {&#10;                        wait();&#10;                    }&#10;                }&#10;                &#10;                currentStep++;&#10;            }&#10;            &#10;            System.out.println(&quot;[COMPLETE] &quot; + name + &quot; successfully obtained &quot; + desiredDocument + &quot;!&quot;);&#10;            &#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;            System.out.println(&quot;[ERROR] &quot; + name + &quot; was interrupted.&quot;);&#10;        }&#10;    }&#10;&#10;    private Office findOfficeForDocument(String documentName) {&#10;        for (Office office : officeMap.values()) {&#10;            if (office.canIssue(documentName)) {&#10;                return office;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bureaucratic-system/src/main/java/org/example/model/Counter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bureaucratic-system/src/main/java/org/example/model/Counter.java" />
              <option name="originalContent" value="package org.example.model;&#10;&#10;import java.util.Random;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.LinkedBlockingQueue;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;public class Counter implements Runnable {&#10;    private static final AtomicInteger counterIdGenerator = new AtomicInteger(1);&#10;&#10;    private final int id;&#10;    private final Office office;&#10;    private final BlockingQueue&lt;Client&gt; queue;&#10;    private volatile CounterStatus status;&#10;    private final Random random;&#10;    private volatile boolean running;&#10;&#10;    public Counter(Office office) {&#10;        this.id = counterIdGenerator.getAndIncrement();&#10;        this.office = office;&#10;        this.queue = new LinkedBlockingQueue&lt;&gt;();&#10;        this.status = CounterStatus.OPEN;&#10;        this.random = new Random();&#10;        this.running = true;&#10;    }&#10;&#10;    public int getId() {&#10;        return id;&#10;    }&#10;&#10;    public CounterStatus getStatus() {&#10;        return status;&#10;    }&#10;&#10;    public int getQueueSize() {&#10;        return queue.size();&#10;    }&#10;&#10;    public void addClient(Client client) throws InterruptedException {&#10;        queue.put(client);&#10;    }&#10;&#10;    public void shutdown() {&#10;        running = false;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        System.out.println(&quot;Counter &quot; + id + &quot; at &quot; + office.getName() + &quot; started.&quot;);&#10;&#10;        while (running) {&#10;            try {&#10;                // Random coffee break&#10;                if (status == CounterStatus.OPEN &amp;&amp; random.nextInt(100) &lt; 2) {&#10;                    status = CounterStatus.COFFEE_BREAK;&#10;                    System.out.println(&quot;⏸️  Counter &quot; + id + &quot; at &quot; + office.getName() + &quot; taking coffee break!&quot;);&#10;                    Thread.sleep(random.nextInt(2000) + 1000);&#10;                    status = CounterStatus.OPEN;&#10;                    System.out.println(&quot;✅ Counter &quot; + id + &quot; at &quot; + office.getName() + &quot; back from coffee break.&quot;);&#10;                }&#10;&#10;                if (status == CounterStatus.OPEN) {&#10;                    Client client = queue.poll();&#10;                    if (client != null) {&#10;                        processClient(client);&#10;                    } else {&#10;                        Thread.sleep(100);&#10;                    }&#10;                } else {&#10;                    Thread.sleep(500);&#10;                }&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;                break;&#10;            }&#10;        }&#10;&#10;        System.out.println(&quot;Counter &quot; + id + &quot; at &quot; + office.getName() + &quot; closed.&quot;);&#10;    }&#10;&#10;    private void processClient(Client client) throws InterruptedException {&#10;        String documentName = client.getCurrentDocumentNeeded();&#10;        System.out.println(&quot; Counter &quot; + id + &quot; at &quot; + office.getName() +&#10;                         &quot; processing &quot; + client.getName() + &quot; for document: &quot; + documentName);&#10;&#10;        // Simulate processing time&#10;        Thread.sleep(random.nextInt(1000) + 500);&#10;&#10;        // Issue document&#10;        client.receiveDocument(documentName);&#10;        System.out.println(&quot;✓  Counter &quot; + id + &quot; at &quot; + office.getName() +&#10;                         &quot; issued &quot; + documentName + &quot; to &quot; + client.getName());&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package org.example.model;&#10;&#10;import java.util.Random;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.LinkedBlockingQueue;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;public class Counter implements Runnable {&#10;    private static final AtomicInteger counterIdGenerator = new AtomicInteger(1);&#10;&#10;    private final int id;&#10;    private final Office office;&#10;    private final BlockingQueue&lt;Client&gt; queue;&#10;    private volatile CounterStatus status;&#10;    private final Random random;&#10;    private volatile boolean running;&#10;&#10;    public Counter(Office office) {&#10;        this.id = counterIdGenerator.getAndIncrement();&#10;        this.office = office;&#10;        this.queue = new LinkedBlockingQueue&lt;&gt;();&#10;        this.status = CounterStatus.OPEN;&#10;        this.random = new Random();&#10;        this.running = true;&#10;    }&#10;&#10;    public int getId() {&#10;        return id;&#10;    }&#10;&#10;    public CounterStatus getStatus() {&#10;        return status;&#10;    }&#10;&#10;    public int getQueueSize() {&#10;        return queue.size();&#10;    }&#10;&#10;    public void addClient(Client client) throws InterruptedException {&#10;        queue.put(client);&#10;    }&#10;&#10;    public void shutdown() {&#10;        running = false;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        System.out.println(&quot;Counter &quot; + id + &quot; at &quot; + office.getName() + &quot; started.&quot;);&#10;&#10;        while (running) {&#10;            try {&#10;                // Random coffee break&#10;                if (status == CounterStatus.OPEN &amp;&amp; random.nextInt(100) &lt; 2) {&#10;                    status = CounterStatus.COFFEE_BREAK;&#10;                    System.out.println(&quot;⏸️  Counter &quot; + id + &quot; at &quot; + office.getName() + &quot; taking coffee break!&quot;);&#10;                    Thread.sleep(random.nextInt(2000) + 1000);&#10;                    status = CounterStatus.OPEN;&#10;                    System.out.println(&quot;✅ Counter &quot; + id + &quot; at &quot; + office.getName() + &quot; back from coffee break.&quot;);&#10;                }&#10;&#10;                if (status == CounterStatus.OPEN) {&#10;                    Client client = queue.poll();&#10;                    if (client != null) {&#10;                        processClient(client);&#10;                    } else {&#10;                        Thread.sleep(100);&#10;                    }&#10;                } else {&#10;                    Thread.sleep(500);&#10;                }&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;                break;&#10;            }&#10;        }&#10;&#10;        System.out.println(&quot;Counter &quot; + id + &quot; at &quot; + office.getName() + &quot; closed.&quot;);&#10;    }&#10;&#10;    private void processClient(Client client) throws InterruptedException {&#10;        String documentName = client.getCurrentDocumentNeeded();&#10;        System.out.println(&quot;[PROCESSING] Counter &quot; + id + &quot; at &quot; + office.getName() + &#10;                         &quot; processing &quot; + client.getName() + &quot; for document: &quot; + documentName);&#10;        &#10;        // Simulate processing time&#10;        Thread.sleep(random.nextInt(1000) + 500);&#10;        &#10;        // Issue document&#10;        client.receiveDocument(documentName);&#10;        System.out.println(&quot;[ISSUED] Counter &quot; + id + &quot; at &quot; + office.getName() + &#10;                         &quot; issued &quot; + documentName + &quot; to &quot; + client.getName());&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>